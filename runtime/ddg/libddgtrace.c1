#include <stdio.h>
#include <string.h>

FILE *out;
FILE *printInvOut;

#define MAX_FUNCTIONS 100
#define MAX_CALL_DEPTH 10000

struct Invariant {
  int Min;
  int Max;
  int FnId; // later add variables, operations, position/pgm point etc.
  char *Fname;
};

int Stack[MAX_CALL_DEPTH] ;
int StackIndex = 0;
char *FNameStack[MAX_CALL_DEPTH] ;
int FNameStackIndex = 0;

struct Invariant *Map[MAX_FUNCTIONS][MAX_FUNCTIONS];
int MapIndex[MAX_FUNCTIONS];

void stackPop(void)
{
  //fprintf(stderr, "Inside stackPop\n"); 
  if( StackIndex == 0 )
    fprintf(stderr, "Empty function stack in invariant library\n");    
  else
    StackIndex--;
}

void fNameStackPop(void)
{
  //fprintf(stderr, "Inside fNameStackPop\n"); 
  if( FNameStackIndex == 0 )
    fprintf(stderr, "Empty function stack in invariant library\n");    
  else
    {
    FNameStackIndex--;
    free( FNameStack[FNameStackIndex] );
    }
}


void stackPush(int FunctionId)
{
  //fprintf(stderr, "Inside stackPush %d\n", FunctionId); 
  if( StackIndex > MAX_CALL_DEPTH )
    fprintf(stderr, "Full function stack in invariant library\n");    
  else
    Stack[StackIndex++] = FunctionId ;
}

void fNameStackPush(char *FunctionName)
{
  //fprintf(stderr, "Inside fNameStackPush %s\n", FunctionName); 
  if( FNameStackIndex > MAX_CALL_DEPTH )
    fprintf(stderr, "Full function stack in invariant library\n");    
  else
    {
    FNameStack[FNameStackIndex] = (char *) malloc( strlen(FunctionName) + 1 );
    strcpy( FNameStack[FNameStackIndex++] , FunctionName );
    }
}

int stackTop(int i)
{
  //fprintf(stderr, "Inside stackTop\n"); 
  if( StackIndex == 0 ||  StackIndex-1-i < 0 )
    fprintf(stderr, "Empty function stack in invariant library or access outside the stack \n");    
  else
    return Stack[StackIndex-1-i];
}

char *fNameStackTop(int i)
{
  //fprintf(stderr, "Inside fNameStackTop\n"); 
  if( FNameStackIndex == 0 ||  FNameStackIndex-1-i < 0 )
    fprintf(stderr, "Empty function stack in invariant library or access outside the stack \n");    
  else
    return FNameStack[FNameStackIndex-1-i];
}

void ddgtrace_init(const char *out_filename) {  
  int i;

  //fprintf(stderr, "Inside ddgtrace_init %s\n", out_filename); 
  out = fopen(out_filename, "w");
  for(i=0; i<MAX_FUNCTIONS; i++)
    MapIndex[i] = 0 ;
}

void trace_fn_start(int *FunctionId, char* FunctionName) {
  //fprintf(stderr, "Inside  trace_fn_start %d %s\n", *FunctionId, FunctionName); 
  if( *FunctionId > MAX_FUNCTIONS )
    fprintf(stderr, "Number of functions exceeds maximum number of allowed functions \n");        
  stackPush(*FunctionId);
  fNameStackPush(FunctionName);
  //fprintf(out, "%s %s\n", "FS", fname);
}

void trace_fn_end(int FunctionId) {
  //fprintf(stderr, "Inside  trace_fn_end\n"); 
  stackPop();
  fNameStackPop();
  //fprintf(out, "%s\n", "FE");
}

void trace_ret_value(signed value) {
  struct Invariant *inv;
  int i = 0;
  int callpath = 0;
  char *fname;

  //fprintf(stderr, "Inside  trace_ret_value %d\n", value); 

  // Find out the entry in the map corresponding to current call path
  callpath = stackTop(0); // Now, only handle call path of one
  fname = fNameStackTop(0);

  //fprintf(stderr, "Handling function id %d\n", callpath); 
  for(i=0; i<MapIndex[callpath]; i++)
     {
       if( Map[callpath][i]->FnId == callpath ) // Invariant already exists
         break;
     }

  if(i < MapIndex[callpath] ) // Invariant already exists
    {
     //fprintf(stderr, "Updating existing invarant\n"); 
     inv =  Map[callpath][i];
     if( inv->Min > value )
       {
       inv->Min = value;
       //fprintf(stderr, "Updating existing invarant\n"); 
       }

     if( inv->Max < value )
       {
       inv->Max = value;      
       //fprintf(stderr, "Updating existing invarant\n"); 
       }
 
    }
  else // Create a new Invariant
    {
     fprintf(stderr, "Creating new invarant\n"); 
     inv = (struct Invariant *) malloc(sizeof(struct Invariant));
     inv->Min = value;
     inv->Max = value;
     inv->FnId = callpath;
     inv->Fname = (char *) malloc( strlen(fname) + 1 );
     strcpy( inv->Fname , fname );

     Map[callpath][MapIndex[callpath]] = inv;
     MapIndex[callpath]++; // Update the map index for current callpath
     if( MapIndex[callpath] > MAX_FUNCTIONS )
       fprintf(stderr, "Number of invarants exceeds maximum number allowed per function \n");        
    }
 
  //fprintf(out, "%s %d\n", fname, value);
}


void printInvariants( )
{
  int i = 0, j = 0;
  //int callpath ;

  printInvOut = fopen("Invariants.txt", "w");

  fprintf(stderr, "Printing invariants\n"); 
  
  for(i=0; i<MAX_FUNCTIONS; i++)
     {
     fprintf(stderr, "%d %d\n", i, MapIndex[i]); 
     if( MapIndex[i] != 0 )
       {
        fprintf(printInvOut, "%d %d\n", i, MapIndex[i]); 
        for(j=0; j<MapIndex[i]; j++)
           {
            fprintf(printInvOut, "%d %s %d %d\n", Map[i][j]->FnId, Map[i][j]->Fname, Map[i][j]->Min, Map[i][j]->Max); 
           }
       }
     }
  //fflush(out);
  fprintf(stderr, "Finished printing invariants\n"); 
}

void check_invariant(int return_value, int *min, int *max)
{
  //assert (return_value >= min) ;
  //printf("%d %d\n", *min, *max);
  if( (return_value < (int)(*min)) || (return_value > (int)(*max)) )
    {
     fprintf(stderr, "Exiting through invariant failure\n");      
     exit(100);
    }
}

void __main()
{
}


/*
#include <stdio.h>

FILE *out;

void ddgtrace_init(const char *out_filename) {
  out = fopen(out_filename, "w");
}

void trace_fn_start(char *fname) {
  fprintf(out, "%s %s\n", "FS", fname);
}

void trace_fn_end(char *fname) {
  fprintf(out, "%s\n", "FE");
}

void trace_ret_value(signed value) {
  fprintf(out, "%s %d\n", "RV", value);
}


void check_invariant(int return_value, int *min, int *max)
{
  //assert (return_value >= min) ;
  //printf("%d %d\n", *min, *max);
  if( (return_value < (int)(*min)) || (return_value > (int)(*max)) )
    exit(100);
}

void __main()
{
}
*/
